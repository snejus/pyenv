#!/usr/bin/env bash
#
# Summary: Display help for a command
#
# Usage: pyenv help [--usage] COMMAND
#
# Parses and displays help contents from a command's source file.
#
# A command is considered documented if it starts with a comment block
# that has a `Summary:' or `Usage:' section. Usage instructions can
# span multiple lines as long as subsequent lines are indented.
# The remainder of the comment block is displayed as extended
# documentation.

set -e
[ -n "$PYENV_DEBUG" ] && set -x

print_help() {
  file=$1
  with_help=${2:+1}

  local -a usage help
  while read -r line; do
    case $line in
      '# Summary:'*)  summary=${line#\# Summary: } ;;
      '# Usage:'*)    usage+=("${line#\# }") ;;
      '#   '*)        usage+=("${line#\# }") ;;
      '# '[A-Za-z]*)  help+=("${line#\# }") ;;
      '#')            help+=("") ;;
      [^#])           break ;;
    esac
  done < "$file"

  printf '%s\n' "${usage[@]}"
  ! (( with_help )) && return 0

  echo
  if (( ${#help} )); then
    printf '%s\n' "${help[@]}"
  else
    echo "${summary:-Sorry, this command is not documented yet.}"
  fi
}

print_all_summaries() {
  BOLD=$'\e[1m'
  RESET=$'\e[0m'
  printf '
Usage: pyenv <command> [<args>]

Some useful pyenv commands are:
'
  grep -oP '^# Summary:\K.*' "${SORTED_PATHS[@]}" | {
    while read -r line; do
      if [[ $line =~ /pyenv-(sh-)?([^/:]+):(.*) ]]; then
        printf '  %-30s %s\n' "$BOLD${BASH_REMATCH[2]}$RESET" "${BASH_REMATCH[3]}"
      fi
    done
  }
  printf '
See "pyenv help <command>" for information on a specific command.
For full documentation, see: https://github.com/pyenv/pyenv#readme
'
  exit 0
}

[[ -n $COMMANDS ]] || COMMANDS=$(pyenv-commands --vars)
eval "$COMMANDS"

if [[ -z $1 ]] || [[ $1 == --pyenv ]]; then
  print_all_summaries
else
  while test $# -gt 0; do
    arg=$1 && shift
    case $arg in
      --complete)
        echo --usage
        exec printf '%s\n' "${SORTED_COMMANDS[@]}"
        ;;
      --usage)
        usage=1
        ;;
      *)
        cmdpath=${COMMAND_TO_PATH[$arg]}
        [[ -n $cmdpath ]] || {
          echo "pyenv: no such command \`$arg'" >&2
          exit 1
        }
        ;;
    esac
  done
  if ! (( usage )); then
    print_help "$cmdpath" --with-help
  else
    if [[ -n "$cmdpath" ]]; then
      print_help "$cmdpath"
    else
      print_help "$0"
    fi
  fi
fi
